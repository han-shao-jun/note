摘要
> u-boot的使命是启动Linux内核，为了开发内核程序方便，u-boot设计了很多方便调试的命令。例如网络命令，方便通过网络下载内核到RAM中；文件系统命令，方便读取存储介质中的文件到RAM中。
## 信息查询

### 1.帮助命令
直接输入 ?，查看所有可用的命令； ？+  cmd  打印cmd的使用方法，

```shell
STM32MP> ?
?         - alias for 'help'
adc       - ADC sub-system
base      - print or set address offset
bdinfo    - print Board Info structure
blkcache  - block cache diagnostics and control
bmp       - manipulate BMP image data
boot      - boot default, i.e., run 'bootcmd'
bootcount - bootcount
bootd     - boot default, i.e., run 'bootcmd'
bootefi   - Boots an EFI payload from memory
bootm     - boot application image from memory
bootp     - boot image via network using BOOTP/TFTP protocol
bootstage - Boot stage command
bootz     - boot Linux zImage image from memory
chpart    - change active partition
clk       - CLK sub-system
cls       - clear screen
cmp       - memory compare
coninfo   - print console devices and information
cp        - memory copy
crc32     - checksum calculation
date      - get/set/reset date & time
dcache    - enable or disable data cache
dfu       - Device Firmware Upgrade
dhcp      - boot image via network using DHCP/TFTP protocol
dm        - Driver model low level access
dns       - lookup the IP of a hostname
...
```

```shell
STM32MP> ? mmc
mmc - MMC sub system

Usage:
mmc info - display info of the current MMC device
mmc read addr blk# cnt
mmc write addr blk# cnt
mmc erase blk# cnt
mmc rescan
mmc part - lists available partition on current mmc device
mmc dev [dev] [part] - show or set current mmc device [partition]
mmc list - lists available devices
mmc hwpartition [args...] - does hardware partitioning
  arguments (sizes in 512-byte blocks):
    [user [enh start cnt] [wrrel {on|off}]] - sets user data area attributes
    [gp1|gp2|gp3|gp4 cnt [enh] [wrrel {on|off}]] - general purpose partition
    [check|set|complete] - mode, complete set partitioning completed
  WARNING: Partitioning is a write-once setting once it is set to complete.
  Power cycling is required to initialize partitions after set to complete.
mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode
 - Set the BOOT_BUS_WIDTH field of the specified device
mmc bootpart-resize <dev> <boot part size MB> <RPMB part size MB>
 - Change sizes of boot and RPMB partitions of specified device
mmc partconf dev [boot_ack boot_partition partition_access]
 - Show or change the bits of the PARTITION_CONFIG field of the specified device
mmc rst-function dev value
 - Change the RST_n_FUNCTION field of the specified device
   WARNING: This is a write-once field and 0 / 1 / 2 are the only valid values.
mmc setdsr <value> - set DSR register value
```

## 环境变量

### 1.查看
在使用一份不熟悉的u-boot(原厂)时，查看环境环境非常重要

语法：不带变量名是打印所有环境变量，带有变量名打印对应变量
```shell
print [value_name]
```

例如：打印 ipaddr 变量值
```shell
STM32MP> print ipaddr
ipaddr=192.168.5.100
```

### 2.修改和添加
修改环境变量和添加环境变量命令是相同，不存在则添加一个，存在则覆盖旧的

```shell
语法：
setenv <value_name>

例如：设置IPV4地址为192.168.5.100
setenv ipaddr 192.168.5.100
```

环境变量中可以引用其他环境变量，还可以是shell脚本命令或则u-boot内置的命令，多个命令需要用分号隔开，甚至可以拼接变量名作为变量值，变量中存在空格需要用引号包裹

```shell
setenv bootcmd 'tftp c2000000 uImage;tftp c4000000 stm32mp157d-atk.dtb;bootm c2000000 - c4000000'  
```

### 3.保存
u-boot中保存环境变量是一个可选项，可以开启也可以关闭，在配置时可以使能。环境变量需要存储介质保存，在配置使能保存环境变量时可以选择保存的介质。一般是flash、sd卡、eMMc，选择flash需要给定保存位置且这块flash区域没有黑使用；选择SD卡和eMMC如果有文件系统可以存进文件系统没有和flash相同的用法，选择一个区域保存。该命令没有参数，直接保存所有已经设置的环境变量。在设置完成环境变量后别忘记 **<font color=#c7254e>保存环境变量</font>**：

```shell
STM32MP> saveenv
Saving Environment to MMC... Writing to MMC(1)... O
```

### 4.加载
在u-boot启动时会自动加载环境变量，环境先是加载编译时默认的环境变量，再从保存环境变量的介质中加载环境变量，还支持从文件中加载环境变量(需要配置u-boot)，一些原厂喜欢用文件保存u-boot环境变量。

```shell
U-Boot 2020.01-stm32mp-r1 (Jun 06 2023 - 21:33:33 +0800)

CPU: STM32MP157DAA Rev.Z
Model: STMicroelectronics STM32MP157D eval daughter
Board: stm32mp1 in trusted mode (st,stm32mp157d-ed1)
DRAM:  1 GiB
Clocks:
- MPU : 800 MHz
- MCU : 208.878 MHz
- AXI : 266.500 MHz
- PER : 24 MHz
- DDR : 533 MHz
WDT:   Started with servicing (32s timeout)
NAND:  0 MiB
MMC:   STM32 SD/MMC: 0, STM32 SD/MMC: 1
Loading Environment from MMC... OK   # 从MMC中加载环境变量
In:    serial
Out:   serial
Err:   serial
invalid MAC address in OTP 00:00:00:00:00:00
Net:   
Warning: ethernet@5800a000 (eth0) using random MAC address - 92:c8:e2:b0:5b:7f
eth0: ethernet@5800a000
Hit any key to stop autoboot:  0
```

## 网络命令
u-boot 支持大量的网络相关命令，比如 dhcp、ping、 nfs 和 tftpboot，

使用以下命名之前需要先设置好环境变量
+ **<font color=#c7254e>ipaddr</font>：地址ipv4地址
+ **<font color=#c7254e>ethaddr</font>：本地mac地址
+ **<font color=#c7254e>gatewayip</font>：本地网关
+ **<font color=#c7254e>netmask</font>：本地子网掩码
+ **<font color=#c7254e>serverip</font>：tftp服务端地址

### 1. ping
开发板的网络能否使用，是否可以和服务器(Ubuntu 主机)进行通信，通过 ping 命令就可以  验证，直接 ping 服务器的 IP 地址即可，命令如下：

语法：
```shell
ping <ipaddr>
```

例如：测试192.168.0.104连通性
```shell
STM32MP> ping 192.168.0.104
Using ethernet@5800a000 device
host 192.168.0.104 is alive
```

注意虚拟机搭建 **<font color=#c7254e>桥接网卡</font>**，实现开发机windos和Linux虚拟机、板卡三方都通，注意！只能在 uboot 中 ping 其他的机器，其他机器不能 ping uboot，因为 uboot 没有对 ping  命令做处理，如果用其他的机器 ping uboot 的话会失败

### 2. dhcp
dhcp 用于从路由器获取 IP 地址，前提是开发板得连接到路由器上的，如果开发板是和电  脑直连的，那么 dhcp 命令就会失效。直接输入 dhcp 命令即可通过路由器获取到 IP 地址，环境变量**ipaddr**被赋值

```shell
STM32MP> dhcp
ethernet@5800a000 Waiting for PHY auto negotiation to complete..... done
BOOTP broadcast 1
BOOTP broadcast 2
BOOTP broadcast 3
DHCP client bound to address 192.168.0.103 (1162 ms)
STM32MP> print ipaddr
ipaddr=192.168.0.103
```

### 3. nfs
uboot 中使用 nfs 命令将 Ubuntu 中的 linux 镜像和设备树下载到开发板的 DRAM 中,，命令格式

```shell
语法：
nfs [loadAddress] [[hostIPaddr:]bootfilename]

例如：拉取uImage文件到C2000000内存中
nfs C2000000 192.168.1.249:/home/super/mp157/nfs/uImage
```

在使用nfs命令时无效可以先排查linux虚拟机nfs环境搭建，还是无效检查u-boot版本，比较新的Linux不在支持nfs v2，但u-boot任使用nfs v2
### 4. tftp
tftp 命令的作用和 nfs 命令一样，都是用于通过网络下载东西到 DRAM 中，只是 tftp 命令使用的是 TFTP 协议， Ubuntu 主机作为 TFTP 服务器，注意设置环境变量 **<font color=#c7254e>serverip</font>，命令格式

```shell
语法：
tftpboot [loadAddress] [[hostIPaddr:]bootfilename]

例如：
tftp C2000000 uImage
```

如果失败查看TFTP 服务器环境搭建，能否ping通TFTP 服务器。
## eMMC 和 SD 卡操作命令

查看所有mmc可用命令

```shell
STM32MP> ? mmc
mmc - MMC sub system

Usage:
mmc info - display info of the current MMC device
mmc read addr blk# cnt
mmc write addr blk# cnt
mmc erase blk# cnt
mmc rescan
mmc part - lists available partition on current mmc device
mmc dev [dev] [part] - show or set current mmc device [partition]
mmc list - lists available devices
mmc hwpartition [args...] - does hardware partitioning
  arguments (sizes in 512-byte blocks):
    [user [enh start cnt] [wrrel {on|off}]] - sets user data area attributes
    [gp1|gp2|gp3|gp4 cnt [enh] [wrrel {on|off}]] - general purpose partition
    [check|set|complete] - mode, complete set partitioning completed
  WARNING: Partitioning is a write-once setting once it is set to complete.
  Power cycling is required to initialize partitions after set to complete.
mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode
 - Set the BOOT_BUS_WIDTH field of the specified device
mmc bootpart-resize <dev> <boot part size MB> <RPMB part size MB>
 - Change sizes of boot and RPMB partitions of specified device
mmc partconf dev [boot_ack boot_partition partition_access]
 - Show or change the bits of the PARTITION_CONFIG field of the specified device
mmc rst-function dev value
 - Change the RST_n_FUNCTION field of the specified device
   WARNING: This is a write-once field and 0 / 1 / 2 are the only valid values.
mmc setdsr <value> - set DSR register value
```

### 1. mmc list 命令
mmc list 命令用于来查看当前开发板一共有几个 MMC 设备

```shell
STM32MP> mmc list
STM32 SD/MMC: 0
STM32 SD/MMC: 1 (eMMC)
```

### 2. mmc rescan 命令
mmc rescan 命令用于扫描当前开发板上所有的 MMC 设备，包括 EMMC 和 SD 卡.

### 3. mmc info 命令
mmc info 命令用于输出当前选中的 mmc info 设备的信息

```shell
STM32MP> mmc info
Device: STM32 SD/MMC
Manufacturer ID: ea
OEM: 10e
Name: SPeMM 
Bus Speed: 52000000
Mode: MMC High Speed (52MHz)
Rd Block Len: 512
MMC version 5.0
High Capacity: Yes
Capacity: 7.3 GiB
Bus Width: 8-bit
Erase Group Size: 464 KiB
HC WP Group Size: 8 MiB
User Capacity: 7.3 GiB WRREL
Boot Capacity: 4 MiB ENH
RPMB Capacity: 4 MiB ENH
```

### 4 . mmc dev 命令
mmc dev 命令用于切换当前操作的 MMC 设备

语法
```sell
mmc dev [dev] [part]
```

例如：切换到设备0
```shell
STM32MP> mmc dev 1
switch to partitions #0, OK
mmc1(part 0) is current device
```

### 5. mmc part 命令
SD 卡或者 EMMC 会有多个分区，可以使用命令“mmc part”来查看当前MMC分区

```shell
STM32MP> mmc part

Partition Map for MMC device 1  --   Partition Type: EFI

Part    Start LBA       End LBA         Name
        Attributes
        Type GUID
        Partition GUID
  1     0x00000400      0x000013ff      "ssbl"
        attrs:  0x0000000000000000
        type:   8da63339-0007-60c0-c436-083ac8230908
        guid:   016f625c-c0bf-4a21-b91f-62b0d7803580
  2     0x00001400      0x000213ff      "boot"
        attrs:  0x0000000000000004
        type:   0fc63daf-8483-4772-8e79-3d69d8477de4
        type:   linux
        guid:   9ffe323b-0fb1-44f8-9da9-49b2e4063b69
  3     0x00021800      0x00e8bfde      "rootfs"
        attrs:  0x0000000000000000
        type:   0fc63daf-8483-4772-8e79-3d69d8477de4
        type:   linux
        guid:   4068db57-e0ec-6843-a926-335d3f9230ae
```

### 6. mmc read 命令
mmc read 命令用于读取 mmc 设备的数据

```shell
语法：
mmc read addr blk# cnt

例如:从mmc 400地址读取0x10字节数据DRAM 0Xc0000000处
mmc read c0000000 400 10
```

## EXT/FAT 格式文件系统操作命令
文件系统相关的是一组命令

### 1.ext4ls/fatls
ext4ls 命令用于查询 EXT4 /FAT格式设备的目录和文件信息

```shell
语法：interface 是要查询的接口，比如 mmc， dev 是要查询的设备号， part 是要查询的分区， directory  是要查询的目录。
ext4ls <interface> [<dev[:part]>] [directory]
fatls <interface> [<dev[:part]>] [directory]

例如：列出MMC1的分区 2 中所有目录和文件
ext4ls mmc 1:2
```

```shell

```
### 2. ext4load/fatload 命令
ext4load/fatload 命令用于将指定的文件读取到 DRAM 中

```shell
语法：interface 是要查询的接口，比如 mmc， dev 是要查询的设备号， part 是要查询的分区， addr  是DRAM地址，filename是文件名
fatload <interface> [<dev[:part]> [<addr> [<filename> [bytes [pos]]]]]

例如：读取MMC1的分区 2 中uImage到DRAM 0xC2000000处
ext4load mmc 1:2 C2000000 uImage
```

### 3. ext4write
ext4wirte 命令用于将 DRAM 中的数据写入到 MMC 设备中

```shell
语法：interface 是要查询的接口，比如 mmc， dev 是要查询的设备号， part 是要查询的分区， addr  是DRAM地址，filename是文件名
ext4write <interface> <dev[:part]> <addr> <absolute filename path> [sizebytes] [file offset]
```

## boot启动命令
启动相关命令是一组命令

重要环境变量
+ **<font color=#c7254e>bootcmd</font>：在倒计时结束后自动执行启动命令
+ **<font color=#c7254e>bootargs</font>：转递给的内核参数，u-boot启动内核时自动读取传递，Linux内核被设计成一个可转递参数的内核

### 1.bootm 命令
bootm 命令用于启动内存中 **<font color=#c7254e>uImage</font>** 镜像文件，可以配置前面的网络命令或则文件系统的命令

```shell
语法：
bootm [addr [arg ...]]

例如：先用tftp拉取文件到DRAM中，再使用bootm命令启动
tftp c2000000 uImage
tftp c2000000 stm32mp157d-atk.dtb
bootm c2000000 - c4000000

例如：先读取文件DRAM中，再使用bootm命令启动
ext4load mmc 1:2 c2000000 uImage
ext4load mmc 1:2 c4000000 stm32mp157d-atk.dtb
bootm c2000000 - c4000000
```

命令 bootm 主要有三个参数， addr 是 Linux 镜像文件在 DRAM 中的位置， 后面的“arg…”  表示其他可选的参数，比如要指定 initrd 的话，第二个参数就是 initrd 在 DRAM 中的地址。如果 Linux 内核使用设备树的话还需要第三个参数，用来指定设备树在 DRAM 中的地址，如果不需要 initrd 的话第二个参数就用‘-’来代替

### 2. bootz 命令
bootz 和 bootm 功能类似，但是 bootz 用于启动 zImage 镜像文件，命令语法也是相同的

```shell
bootz [addr [initrd[:size]] [fdt]]
```

### 3. booti 命令
booti 和bootm功能类似，但是 bootz 用于启动 ARM64 kernel Image（`Image`） 镜像文件，命令语法也是相同的

```shell
booti addr [initrd[:size]] [fdt]
```

### 4. boot 和 bootd 命令
此命令也是用来启动 Linux 系统的， boot 会读取环境变量 **<font color=#c7254e>bootcmd</font>**  并执行来启动 Linux 系统，这个环境变量保存着引导命令，其实就是多条启动命令的集合，具体的引导命令内容是可以修改的。

```shell
例如：
setenv bootcmd 'tftp c2000000 uImage;tftp c4000000 stm32mp157d-atk.dtb;bootm c2000000 - c4000000'  
saveenv  
boot
```
## MII命令
MII 命令是网络相关命令，主要用于读取网络 PHY 芯片寄存器，在 uboot 中调试网络 PHY 芯片的时候非常有用！ 另外， MDIO 命令也是与网络 PHY 芯片有关的，但mii命令更好用。

查看mii可用命令

```shell
U-Boot > ? mii
mii - MII utility commands

Usage:
mii device                            - list available devices
mii device <devname>                  - set current device
mii info   <addr>                     - display MII PHY info
mii read   <addr> <reg>               - read  MII PHY <addr> register <reg>
mii write  <addr> <reg> <data>        - write MII PHY <addr> register <reg>
mii modify <addr> <reg> <data> <mask> - modify MII PHY <addr> register <reg>
                                        updating bits identified in <mask>
mii dump   <addr> <reg>               - pretty-print <addr> <reg> (0-5 only)
Addr and/or reg may be ranges, e.g. 2-7.
```

### 1.mii device 
查看可用mdio设备

```shell
U-Boot > mii device
MII devices: 'mdio' 
Current device: 'mdio'
```

### 2.mii dump
打印寄存器值，寄存器0-5是IEEE802.3规范的寄存器，打印这些寄存器可以显示相应位对应含义，打印phy=0, reg=0寄存器值，

```shell
U-Boot > mii dump 0 0
0.     (3100)                 -- PHY control register --
  (8000:0000) 0.15    =     0     reset
  (4000:0000) 0.14    =     0     loopback
  (2040:2000) 0. 6,13 =   b01    speed selection = 100 Mbps
  (1000:1000) 0.12    =     1     A/N enable
  (0800:0000) 0.11    =     0     power-down
  (0400:0000) 0.10    =     0     isolate
  (0200:0000) 0. 9    =     0     restart A/N
  (0100:0100) 0. 8    =     1     duplex = full
  (0080:0000) 0. 7    =     0     collision test enable
  (003f:0000) 0. 5- 0 =     0     (reserved)
```

### 3.mii read
读取寄存器值

语法：
```
mii read   <addr> <reg>
```

例如：读取phy=0, reg=0寄存器值
```shell
U-Boot > mii read 0 0
3100
```